{"name":"Ysignalslot","tagline":"Header only c++ signal slot mechanism implemantation","body":"# YSignalSlot\r\n\r\n\r\nYSignalSlot is a header only C++ library. It is an implementation of signal-slot mechanism via\r\nC++. It is similar to C++ signal, Boost::signal and SigSlot. It intensively uses C++11 features.\r\n\r\n-------------------------------------------------------------------------------------------------------\r\n\r\nAdvantages:\r\n- Almost everything is compile-time. So it is fast.\r\n- It can be used with single slot function or unlimited slot functions.\r\n- “emit” function’s return type is pointer of your actual slot function’s return type and it\r\ncan be any type.\r\n- It supports “void” return type.\r\n- Slot(s) can be set to enable or disable. If slot(s) is/are disabled, signal can’t emit\r\nthis/these slot(s).\r\n- If slot which emitted is disabled or its return type is void, “emit” function returns “NULL”\r\npointer.\r\n- It works with member slot functions.\r\n- Slot functions’ signatures are converted and stored as string.\r\n- Slot functions’ argument counts and receivers are stored.\r\n- It uses meta programming methods for “static for loop” and “static if”.\r\n- Signals can be used nested.\r\n- Receivers can be “this” pointer.\r\n- It is free and LGPL licensed.\r\n- It uses C++11 features.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nDisadvantages:\r\n- It works only member functions.\r\n- Executable size may be large. Because codes generated at compile-time, not run-time.\r\n- It doesn’t works with “const” member functions. ( like “int function1(int) const;” )\r\n- Users must add “-std=c++0x” flag to compiler. This is required for using C++11.\r\n- It generates a struct inside the class where you define signal. So it uses a little more code\r\nsize.\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}